use robot as knowledge.

module robotEvents {
	% Update the agent's state of movement.
	forall bel( state(State)), percept(state(NewState))  
		do delete( state(State) ) + insert( state(NewState) ).
	
	% Record when we are entering or leaving a room.
	forall percept(in(Place)) do insert( in(Place) ).
	forall percept(not(in(Place))) do delete( in(Place) ).

	% Exercise 2.1b: insert rules for handling percepts other than "sendonce" percepts.
	forall bel( at(Place)), percept(at(NewPlace))  
		do delete( at(Place) ) + insert( at(NewPlace) ).
		
	% Update atBlock
	forall percept(atBlock(Place)) do insert(atBlock(Place)).
	forall percept(not(atBlock(Place))) do delete(atBlock(Place)).
	
	% Insert new block colours
	forall percept(color(Block, Color)), not(bel(color(Block, Color))) 
		do insert(color(Block, Color)).
	
	% Update in
	if percept(in(Room)) then insert(in(Room)).
	if percept(not(in(Room))) then delete(in(Room)).
	
	if percept(in(Room)), not(bel(visited(Room))), not(bel(Room = 'DropZone')) 
		then insert(visited(Room)).
	
	% Update sequence index
	if bel(sequenceIndex(Index)), percept(sequenceIndex(NewIndex)) 
		then delete(sequenceIndex(Index)) + insert (sequenceIndex(NewIndex)) .
		
	forall percept(color(Block, Color)), percept(in(Room)), not(bel(block(Block, Room))) 
		do insert (block(Block, Room)).
		
	% Delete block/2 when block is not in the room anymore 
	forall percept( in(PlaceID) ), bel(block(BlockID, PlaceID)), not(percept(color(BlockID, PlaceID)))
			do delete ( block(BlockID, PlaceID) ) + allother.send(not(blockPlaceID(BlockID, PlaceID))).
	
	% Save room information and send it to the other agent	
	forall percept(color(Block, Color)), percept(in(Place))
		do insert(color(Block, Color)) + insert(block(Block, Place)) + allother.send(color(Block, Color)) + allother.send(block(Block, Place)).
		
	% 
	forall (Player).sent(not(block(Block, Place)))
		do delete(block(Block, Place)).
		
	forall (Player).sent(color(Block, Color)), (Player).sent(block(Block, Place))
		do insert(color(Block, Color)) + insert(block(Block, Place)) + insert(visited(Place)).
		
	% Update holding
	forall percept(holding(Block), in(Place)) do insert( holding(Block) ) + delete(block(Block, Place)).
	forall percept(not(holding(Block))) do delete( holding(Block) ).

	
	% if percept(holding(Block)), bel(in(Room)) then delete(block(Block, Room)).
	
	% Exercise 2.5b: insert code for goal management that allows an agent to systematically search for blocks. (if needed)
	%if a-goal(in(Room)), bel(visited(Room)) then drop(in(Room)).
	%if bel( nextColorInSeq(Color)), bel(color(Block, Color)), bel(block(Block, Room)), not(bel(in(Room))) then adopt (in(Room)).
	%if bel( nextColorInSeq(Color)), bel(color(Block, Color)), bel(block(Block, Room)), bel(in(Room)) then adopt (atBlock(Block)).
	
	% Exercise 2.6b: insert code for goal management that makes the agent deliver a block when it 
	%   knows about a block that can be delivered. (if needed)
	%if bel(atBlock(Block), nextColorInSeq(Color), color(Block, Color) ) then adopt(holding(Block)).
	%if a-goal(holding(Block)), bel(nextColorInSeq(OtherColor), color(Block, Color)), not(bel(OtherColor = Color)) then drop(holding(Block)).
	%if not(a-goal(in('DropZone'))), bel(holding(Block), not(in('DropZone'))) then adopt(in('DropZone')).
	
	% This will cause the agent to drop al it's goals when the sequence is complete.
	%if bel( sequenceIndex(X), X =:= 6 ) then{
    %	forall goal(in(Y)) do drop(in(Y)).
    %}
}
